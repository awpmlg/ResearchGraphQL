# ResearchGraphQL

# Оглавление

- [Что такое GraphQL?](#title1)
  - [Как работает GraphQL](#title1_1)
  - [Что такое схема GraphQL?](#title1_2)
  - [Что такое запросы GraphQL?](#title1_3)
  - [Что такое мутации GraphQL?](#title1_4)
  - [Компоненты запросов и мутаций](#title1_5)
    - [Поля](#title1_1_1)
    - [Аргументы](#title1_1_2)
    - [Переменные](#title1_1_3)
    - [Псевдонимы](#title1_1_4)
    - [Фрагменты](#title1_1_5)
  - [Подписки](#title1_6)
  - [Самоанализ](#title1_7)
- [Уязвимости API GraphQL](#title2)
- [Поиск конечных точек GraphQL](#title3)
  - [Универсальные запросы](#title3_1)
  - [Общие имена конечных точек](#title3_2)
  - [Методы запроса](#title3_3)
  - [Первоначальное тестирование](#title3_4)
- [Использование непроверенных аргументов](#title4)
- [Обнаружение информации о схеме](#title5)
  - [Использование самоанализа](#title5_1)
  - [Зондирование для самоанализа](#title5_2)
  - [Выполнение полного запроса самоанализа](#title5_3)
  - [Визуализация результатов самоанализа](#title5_4)
  - [Использование InQL](#title5_5)
  - [Предложения(Suggestions)](#title5_6)
- [Обход защиты самоанализа GraphQL](#title6)
- [Обход ограничения скорости с помощью псевдонимов](#title7)
- [GraphQL CSRF](#title8)
  - [Как возникают уязвимости GraphQL CSRF?](#title8_1)
- [Предотвращение атак](#title9)
  - [Предотвращение атак грубой силы GraphQL](#title9_1)
  - [Предотвращение GraphQL CSRF](#title9_2)

# <a id="title1">Что такое GraphQL?</a>

GraphQL — это язык запросов API, предназначенный для обеспечения эффективной связи между клиентами и серверами. Это позволяет пользователю точно указать, какие данные он хочет получить в ответе, помогая избежать больших объектов ответа и множественных вызовов, которые иногда можно увидеть с помощью REST API. 

Службы GraphQL устроены так, что клиенту не нужно знать, где находятся данные. Вместо этого клиенты отправляют запросы на сервер GraphQL, который извлекает данные из соответствующих мест. Поскольку GraphQL не зависит от платформы, его можно реализовать с помощью широкого спектра языков программирования и использовать для взаимодействия практически с любым хранилищем данных.

## <a id="title1_1">Как работает GraphQL</a>

Схемы GraphQL определяют структуру данных службы, перечисляя доступные объекты (известные как типы), поля и отношения. 

С данными, описанными схемой GraphQL, можно манипулировать с помощью трех типов операций:
- `Запросы`(Queries) на получение данных;
- `Мутации`(Mutations) добавляют, изменяют или удаляют данные;
- `Подписки`(Subscriptions) аналогичны запросам, но устанавливают постоянное соединение, с помощью которого сервер может упреждающе передавать данные клиенту в указанном формате.

Все операции GraphQL используют одну и ту же конечную точку и обычно отправляются как запрос POST. Это существенно отличается от API-интерфейсов REST, которые используют конечные точки для конкретных операций в ряде методов HTTP. В GraphQL тип и имя операции определяют способ обработки запроса, а не конечную точку, в которую он отправляется, или используемый метод HTTP. 

Службы GraphQL обычно реагируют на операции с объектом JSON в запрошенной структуре.

## <a id="title1_2">Что такое схема GraphQL?</a>

В GraphQL схема представляет собой контракт между внешним и внутренним интерфейсом службы. Он определяет данные, доступные как ряд типов, используя удобочитаемый язык определения схемы. Затем эти типы могут быть реализованы службой.

Большинство определенных типов являются объектными типами. которые определяют доступные объекты, поля и аргументы, которые у них есть. Каждое поле имеет свой собственный тип, который может быть либо другим объектом, либо скаляром, перечислением, объединением, интерфейсом или пользовательским типом.
```
#Example schema definition 
type Product { 
    id: ID! 
    name: String! 
    description: String! 
    price: Int 
}
```

## <a id="title1_3">Что такое запросы GraphQL?</a>

Запросы GraphQL извлекают данные из хранилища данных. Они примерно эквивалентны запросам GET в REST API. 

Запросы обычно состоят из следующих ключевых компонентов:
- `Тип операции запроса`(query). Технически это необязательно, но рекомендуется, так как явно сообщает серверу, что входящий запрос является запросом;
- `Имя запроса`. Это может быть что угодно. Имя запроса указывать необязательно, но рекомендуется, так как оно может помочь при отладке;
- `Структура данных`. Это данные, которые должен вернуть запрос;
- Необязательно, `один` или `несколько аргументов`. Они используются для создания запросов, которые возвращают сведения о конкретном объекте (например, «дайте мне имя и описание продукта с идентификатором 123»).
```
#Example query
query myGetProductQuery { 
    getProduct(id: 123) { 
        name 
        description 
    } 
}
```
В приведенном выше примере показан запрос с именем `myGetProductQuery`, который запрашивает поля имени и описания продукта с идентификатором `123`.

Обратите внимание, что тип продукта может содержать больше полей в схеме, чем запрошено здесь. Возможность запрашивать только те данные, которые вам нужны, является значительной частью *гибкости* GraphQL.

## <a id="title1_4">Что такое мутации GraphQL?</a>

Мутации каким-то образом изменяют данные, добавляя, удаляя или редактируя их. Они примерно эквивалентны методам POST, PUT и DELETE REST API. 

Как и запросы, мутации имеют тип операции, имя и структуру возвращаемых данных. Однако мутации всегда требуют ввода некоторого типа. Это может быть встроенное значение, но на практике оно обычно предоставляется как переменная.
```
#Example mutation request 
mutation { 
    createProduct(name: "Flamin' Cocktail Glasses", listed: "yes") { 
        id 
        name
        listed 
    } 
}

#Example mutation response 
{
    "data": {
        "createProduct": { 
            "id": 123, 
            "name": "Flamin' Cocktail Glasses", 
            "listed": "yes" 
        } 
    } 
}
```

## <a id="title1_5">Компоненты запросов и мутаций</a>

Синтаксис GraphQL включает в себя несколько общих компонентов для запросов и мутаций:

### <a id="title1_1_1">Поля</a>

Все типы GraphQL содержат элементы запрашиваемых данных, называемых полями. Когда вы отправляете запрос или мутацию, вы указываете, какие поля вы хотите, чтобы API возвращал. Ответ отражает содержимое, указанное в запросе.
```
#Request 
query myGetEmployeeQuery { 
    getEmployees { 
        id 
        name { 
            firstname 
            lastname 
        } 
    } 
}

#Response 
{ 
    "data": {
        "getEmployees": [ 
            { 
                "id": 1, 
                "name" {
                    "firstname": "Carlos", 
                    "lastname": "Montoya"
                } 
            }, 
            { 
                "id": 2,
                "name" { 
                    "firstname": "Peter", 
                    "lastname": "Wiener" 
                } 
            }
        ] 
    } 
}
```
В приведенном выше примере показан запрос для получения сведений об идентификаторах и именах всех сотрудников и связанный с ним ответ. В этом случае запрашиваются поля `id`, `name.firstname` и `name.lastname`.

### <a id="title1_1_2">Аргументы</a>

Аргументы — это значения, которые предоставляются для определенных полей. Аргументы, которые могут быть приняты для типа, определены в схеме.

Когда вы отправляете запрос или мутацию, содержащую аргументы, сервер GraphQL определяет, как ответить на основе его конфигурации. Например, он может возвращать конкретный объект, а не сведения обо всех объектах.
```
#Example query with arguments 
query myGetEmployeeQuery { 
    getEmployees(id:1) { 
        name { 
            firstname 
            lastname 
        } 
    } 
}

#Response to query 
{ 
    "data": { 
        "getEmployees": [ 
        { 
            "name" { 
                "firstname": Carlos, 
                "lastname": Montoya
            } 
        } 
        ] 
    } 
}
```
В приведенном выше примере показан запрос `getEmployee`, который принимает идентификатор сотрудника в качестве аргумента. В этом случае сервер отвечает только сведениями о сотруднике, который соответствует этому идентификатору.

*Примечание: Если предоставленные пользователем аргументы используются для прямого доступа к объектам, API GraphQL может быть уязвим для уязвимостей управления доступом, таких как небезопасные прямые ссылки на объекты (IDOR).*

### <a id="title1_1_3">Переменные</a>

Переменные позволяют передавать динамические аргументы вместо того, чтобы иметь аргументы непосредственно в самом запросе.

Запросы на основе переменных используют ту же структуру, что и запросы со встроенными аргументами, но некоторые аспекты запроса берутся из отдельного словаря переменных на основе JSON. Они позволяют повторно использовать общую структуру в нескольких запросах, при этом изменяется только значение самой переменной.

При построении запроса или мутации, в которой используются переменные, вам необходимо:
- Объявить переменную и тип;
- Добавить имя переменной в соответствующее место в запросе;
- Передать ключ и значение переменной из словаря переменных.
```
#Example query with variable 
query getEmployeeWithVariable($id: ID!) { 
    getEmployees(id:$id) { 
        name { 
            firstname 
            lastname 
        }
    } 
}

Variables: 
{ 
    "id": 1 
}
```
В приведенном выше примере показан тот же запрос, что и в предыдущем примере, но с идентификатором, переданным как переменная, а не как непосредственная часть строки запроса.

В этом примере переменная объявлена в первой строке с помощью `($id: ID!)`. *!* указывает, что это обязательное поле для данного запроса. Затем он используется в качестве аргумента во второй строке с `(id:$id)`. Наконец, значение самой переменной устанавливается в словаре переменной JSON. 

### <a id="title1_1_4">Псевдонимы</a>

Объекты GraphQL не могут содержать несколько свойств с одинаковыми именами. Например, следующий запрос недействителен, так как он дважды пытается вернуть тип продукта.
```
#Invalid query 
query getProductDetails { 
    getProduct(id: 1) { 
        id 
        name 
    } 
    getProduct(id: 2) { 
        id 
        name 
    } 
}
```
**Псевдонимы** позволяют обойти это ограничение, явно называя свойства, которые должны возвращаться API. Вы можете использовать псевдонимы для возврата нескольких экземпляров одного и того же типа объекта в одном запросе. Это помогает сократить количество необходимых вызовов API.
```
#Valid query using aliases 
query getProductDetails { 
    product1: getProduct(id: "1") { 
        id 
        name 
    } 
    product2: getProduct(id: "2") { 
        id 
        name 
    } 
}

#Response to query 
{ 
    "data": { 
        "product1": { 
            "id": 1, 
            "name": "Juice Extractor" 
        }, 
        "product2": { 
            "id": 2, 
            "name": "Fruit Overlays" 
        }
    } 
}
```
В приведенном выше примере запрос использует псевдонимы для указания уникального имени для обоих продуктов. Этот запрос теперь проходит проверку, и детали возвращаются.

*Примечание: Использование псевдонимов с мутациями позволяет эффективно отправлять несколько сообщений GraphQL в одном HTTP-запросе.*

### <a id="title1_1_5">Фрагменты</a>

Фрагменты — это повторно используемые части запросов или мутаций. Они содержат подмножество полей, принадлежащих связанному типу.

После определения их можно включать в запросы или мутации. Если они впоследствии изменяются, это изменение включается в каждый запрос или изменение, вызывающее фрагмент.
```
#Example fragment 
fragment productInfo on Product { 
    id 
    name 
    listed 
}

#Query calling the fragment 
query { 
    getProduct(id: 1) { 
        ...productInfo 
        stock 
    } 
}

#Response including fragment fields 
{ 
    "data": { 
        "getProduct": { 
            "id": 1, 
            "name": "Juice Extractor", 
            "listed": "no", 
            "stock": 5 
        } 
    } 
}
```
В приведенном выше примере показан запрос `getProduct`, в котором сведения о продукте содержатся во фрагменте `productInfo`.

## <a id="title1_6">Подписки</a>

Подписки — это особый тип запросов. Они позволяют клиентам устанавливать долговременное соединение с сервером, чтобы сервер мог затем отправлять клиенту обновления в режиме реального времени без необходимости постоянного опроса данных. Они в первую очередь полезны для небольших изменений в больших объектах и для функций, требующих небольших обновлений в реальном времени (таких как системы чата или совместное редактирование).

Как и в случае с обычными запросами и мутациями, запрос на подписку определяет форму возвращаемых данных.

*Примечание: Подписки обычно реализуются с использованием WebSockets.*

## <a id="title1_7">Самоанализ</a>

Самоанализ — это встроенная функция GraphQL, которая позволяет запрашивать у сервера информацию о схеме. Он обычно используется такими приложениями, как IDE GraphQL и инструментами для создания документации.

Как и в обычных запросах, вы можете указать поля и структуру ответа, который хотите вернуть. Например, вы можете захотеть, чтобы ответ содержал только имена доступных мутаций. 

Самоанализ может представлять серьезный риск раскрытия информации, поскольку его можно использовать для доступа к потенциально конфиденциальной информации (например, к описаниям полей) и помочь злоумышленнику узнать, как он может взаимодействовать с API. *Лучше всего отключать самоанализ в производственных средах.*

# <a id="title2">Уязвимости API GraphQL</a>

Уязвимости GraphQL обычно возникают из-за недостатков реализации и дизайна. Например, функцию самоанализа можно оставить активной, что позволит злоумышленникам запрашивать API, чтобы получить информацию о его схеме.

Атаки GraphQL обычно принимают форму вредоносных запросов, которые могут позволить злоумышленнику получить данные или выполнить несанкционированные действия. Эти атаки могут иметь серьезные последствия, особенно если пользователь может получить права администратора, манипулируя запросами или выполняя атаку CSRF. Уязвимые API-интерфейсы GraphQL также могут привести к проблемам с раскрытием информации

# <a id="title3">Поиск конечных точек GraphQL</a>

Прежде чем мы сможем протестировать GraphQL API, нам сначала нужно найти его конечную точку. Поскольку API-интерфейсы GraphQL используют одну и ту же конечную точку для всех запросов, это ценная информация.

*Примечание: Burp Scanner может автоматически проверять конечные точки GraphQL в рамках сканирования. При обнаружении любых таких конечных точек возникает проблема «GraphQL endpoint found».*
 
## <a id="title3_1">Универсальные запросы</a>

Если вы отправляете запрос`{__typename}` любой конечной точке GraphQL, он будет включать строку `{"data": {"__typename": "query"}}` где-то в своем ответе. Это называется универсальным запросом и является полезным инструментом для проверки того, соответствует ли URL-адрес службе GraphQL.

Запрос работает, потому что каждая конечная точка GraphQL имеет зарезервированное поле с именем `__typename`, которое возвращает тип запрашиваемого объекта в виде строки.

## <a id="title3_2">Общие имена конечных точек</a>

Службы GraphQL часто используют аналогичные суффиксы конечных точек. При тестировании конечных точек GraphQL следует отправлять универсальные запросы в следующие места:
- /graphql
- /api
- /api/graphql
- /graphql/graphql

Если эти общие конечные точки не возвращают ответ GraphQL, вы также можете попробовать добавить /v1 к пути.

*Примечание: Службы GraphQL часто отвечают на любой запрос, отличный от GraphQL, с ошибкой «запрос отсутствует» или аналогичной ошибкой.*

## <a id="title3_3">Методы запроса</a>

Следующим шагом в попытке найти конечные точки GraphQL является тестирование с использованием различных методов запроса.

Для рабочих конечных точек GraphQL рекомендуется принимать только запросы POST, которые имеют тип содержимого `application/json`, так как это помогает защититься от уязвимостей CSRF. Однако некоторые конечные точки могут принимать альтернативные методы, такие как запросы GET или запросы POST, которые используют тип содержимого `x-www-form-urlencoded`. 

Если не получается найти конечную точку GraphQL, отправляя запросы POST на общие конечные точки, можно попробовать повторно отправить универсальный запрос, используя альтернативные методы HTTP.

## <a id="title3_4">Первоначальное тестирование</a>

Как только вы обнаружите конечную точку, вы можете отправить несколько тестовых запросов, чтобы узнать немного больше о том, как она работает. Если конечная точка обеспечивает работу веб-сайта, попробуйте изучить веб-интерфейс в Burp и использовать историю HTTP для проверки отправленных запросов.

# <a id="title4">Использование непроверенных аргументов</a>

Тестирование аргументов запроса — хорошее место для начала тестирования.

Если API использует аргументы для прямого доступа к объектам, он может быть уязвим для уязвимостей управления доступом. Пользователь потенциально может получить доступ к информации, которой у него не должно быть, просто указав аргумент, соответствующий этой информации. Иногда это называют небезопасной прямой ссылкой на объект (IDOR).

Например, следующий запрос запрашивает список товаров для интернет-магазина:
```
#Example product query 
query { 
    products { 
        id 
        name 
        listed 
    } 
}
```
Возвращенный список продуктов содержит только перечисленные продукты.
```
#Example product response 
{ 
    "data": { 
        "products": [ 
            { 
                "id": 1, 
                "name": "Product 1", 
                "listed": true 
            }, 
            { 
                "id": 2, 
                "name": "Product 2", 
                "listed": true 
            }, 
            { 
                "id": 4, 
                "name": "Product 4", 
                "listed": true 
            } 
        ] 
    } 
}
```
Из этой информации мы можем сделать следующие выводы:
- Продуктам присваивается последовательный идентификатор;
- Код продукта 3 отсутствует в списке, возможно, потому, что он был исключен из списка(из-за переменной “listed”).

Запрашивая идентификатор отсутствующего продукта, мы можем получить его детали, даже если он не указан в магазине и не был возвращен исходным запросом продукта.
```
#Query to get missing product 
query { 
    product(id: 3) { 
        id 
        name 
        listed 
    } 
}

#Missing product response 
{ 
    "data": { 
        "product": { 
            "id": 3, 
            "name": "Product 3", 
            "listed": no 
        } 
    } 
}
```

# <a id="title5">Обнаружение информации о схеме</a>

Следующим шагом в тестировании API является сбор информации о базовой схеме.

Лучший способ сделать это — использовать запросы самоанализа. Самоанализ — это встроенная функция GraphQL, которая позволяет запрашивать у сервера информацию о схеме.

Самоанализ поможет понять, как можно взаимодействовать с GraphQL API. Он также может раскрывать потенциально конфиденциальные данные, такие как поля описания.

## <a id="title5_1">Использование самоанализа</a>

Чтобы использовать самоанализ для обнаружения информации о схеме, нужно запросить поле `__schema`. Это поле доступно для корневого типа всех запросов.

Как и в обычных запросах, можно указать поля и структуру ответа, который вернется при выполнении запроса самоанализа. Например, можно построить запрос так, чтобы ответ содержал только названия доступных мутаций.

## <a id="title5_2">Зондирование для самоанализа</a>

Лучше всего отключать самоанализ в производственных средах, но этот совет не всегда соблюдается.

Можно провести самоанализ, используя следующий простой запрос. Если самоанализ включен, ответ возвращает имена всех доступных запросов.
```
#Introspection probe request 
{ 
"query": "{__schema{queryType{name}}}" 
}
```
*Примечание: Burp Scanner может автоматически проверять самоанализ во время сканирования. Если он обнаруживает, что самоанализ включен, он сообщает о проблеме «GraphQL introspection enabled».*

## <a id="title5_3">Выполнение полного запроса самоанализа</a>

Следующим шагом является выполнение полного запроса самоанализа к конечной точке, чтобы получить как можно больше информации о базовой схеме.

Приведенный ниже пример запроса возвращает полную информацию обо всех запросах, мутациях, подписках, типах и фрагментах.

## <a id="title5_4">Визуализация результатов самоанализа</a>

## <a id="title5_5">Использование InQL</a>

## <a id="title5_6">Предложения(Suggestions)</a>

# <a id="title6">Обход защиты самоанализа GraphQL</a>

# <a id="title7">Обход ограничения скорости с помощью псевдонимов</a>

# <a id="title8">GraphQL CSRF</a>

## <a id="title8_1">Как возникают уязвимости GraphQL CSRF?</a>

# <a id="title9">Предотвращение атак</a>

## <a id="title9_1">Предотвращение атак грубой силы GraphQL</a>

## <a id="title9_2">Предотвращение GraphQL CSRF</a>
